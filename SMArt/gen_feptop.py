### import pre-requisite modulesimport osimport sysimport globimport re"""SMArt_fd = os.path.abspath(os.getcwd())for _ in range(2):    SMArt_fd = os.path.split(smart_fd)[0]sys.path.insert(0, smart_fd)#"""### import SMArt & related functionsimport SMArtfrom SMArt.md import parse_topfrom SMArt import alchemy### get processed topology file & molecules to update# l_inputs = ['gen_feptop.py', '-a', 'P8V.top', '-b', 'P8W.top', '-i', 'P8V']l_inputs = sys.argv### parse user inputsf_topolA = l_inputs[l_inputs.index('-a') + 1]f_topolB = l_inputs[l_inputs.index('-b') + 1]ligcode = l_inputs[l_inputs.index('-i') + 1]### set I/Opath_data = os.path.abspath(os.path.join(os.path.split(SMArt.__file__)[0], '..', 'Ligands', ligcode))path_out = os.path.abspath(os.path.join(path_data, 'Output'))if not os.path.isdir(path_out):    os.mkdir(path_out)### check for required files...ligA = f_topolA.split('.')[0]ligB = f_topolB.split('.')[0]### ... .top filesif not os.path.exists(os.path.join(path_data, f'{ligA}.top')):    raise Exception(f'{ligA}.top not available. Exiting...')if not os.path.exists(os.path.join(path_data, f'{ligB}.top')):    raise Exception(f'{ligB}.top not available. Exiting...')### ... .itp filesif not os.path.exists(os.path.join(path_data, f'{ligA}.itp')):    raise Exception(f'{ligA}.itp not available. Exiting...')if not os.path.exists(os.path.join(path_data, f'{ligB}.itp')):    raise Exception(f'{ligB}.itp not available. Exiting...')### ... .prm filesif not os.path.exists(os.path.join(path_data, f'{ligA}.prm')):    raise Exception(f'{ligA}.prm not available. Exiting...')if not os.path.exists(os.path.join(path_data, f'{ligB}.prm')):    raise Exception(f'{ligB}.prm not available. Exiting...')# sys.exit()### parse ligand topologypath_topA = os.path.join(path_data, f'{ligA}.top')topA = parse_top(path_topA, format_type='gm', allow_multiple_matches=True)### parse modified ligand topologypath_topB = os.path.join(path_data, f'{ligB}.top')topB = parse_top(path_topB, format_type='gm', allow_multiple_matches=True)### match strutures using MCS & print top two solutions# mt1, mt2 = topA.molecule_types[f'{ligA}'], topB.molecule_types[f'{ligB}']mt1, mt2 = topA.molecule_types[ligA], topB.molecule_types[ligB]mcs = alchemy.point_mutation(mt1, mt2)print(mcs.solutions[0]) # the top solution# print(mcs.solutions[1]) ### generate topology files for GROMACSsol = alchemy.generate_2state_top(mcs, ff_dumm=topA.get_DUM_type) # solution = 0 by defaultpath_itpout = os.path.join(path_out, 'toptp.itp')sol.toptp.write_itp(path_itpout, flag_generate_excl_pairs=True)# path_top_out = os.path.join(path_out, 'toptp.top')# sol.toptp.write_top(path_top_out, format_type='gm')