# -*- coding: utf-8 -*-
"""
Created on Wed Mar 31 10:42:05 2021

@author: MartinC
"""

### utilities
# import sys

### data 
import numpy as np
import pandas as pd

### IO
# import pyodbc
# import pickle

### modeling
# import statsmodels.tsa.api as tsa
# import warnings
# warnings.filterwarnings('ignore') # only when code is complete (statsmodels warnings are obnoxious)
# import sklearn.metrics as sklm
import sklearn.ensemble as skle

### plotting
# import matplotlib.pyplot as plt
# import matplotlib.dates as mdates
# import seaborn as sns


##### CLASS OBJECT FOR BUILDING TIME SERIES RANDOM FOREST REGRESSOR
#----------------------------------------------------------------------------#
### create class object
class build_model:
    '''
    REQUIREMENTS
    - Make sure index is in datetime format w/ a monthly frequency... HOW TO MAKE MORE ROBUST?
    - Supply pandas dataframe filtered to a single unit (user-defined)
    - Supply date for splitting data into training versus forecasting
    '''

### initialization parameters
    def __init__(self, df=None, date_split=None):
        '''
        - df = data w/ datetime index @ monthly frequency (dataframe)
        - date_split = date to split training/validation from forecasting (string)
        '''

### format date for splitting data
        date_split = pd.to_datetime(date_split) + pd.DateOffset(months=1) # enable usage of indicator variables from next month
        self.date_split = date_split # date on which to split b/w training/testing & actual forecasting

### format data & assign to self (minor changes which are universal)
        self.source_data = df.sort_index().copy() # keep source data available if modifications are made
        self.validate_data = self.source_data[self.source_data.index <= date_split].copy() # data for building model
        self.forecast_data = self.source_data.copy() # data for making forecasts (requires leading variables)
        
### need to know how to split the data (b/w historical & forecasting)
        if not self.date_split:
            raise Exception('Please supply most recent date w/ data on prediction variable... Exiting.')        


### function for walk-forward model validation
    def walk_forward_validation(self, predvar=None, l_exovar=None, l_indvar=None, t_split=12):
        '''
        Performs walk-forward validation on a random forest model using 1000 estimators & the following parameters:
            - df = data generated by `form_FHA.py` (pandas dataframe)
            - predvar = variable you're trying to forecast (string)
            - l_exovar = exogeneous variables to use (list)
            - l_indvar = indicator variables to use (list)... variables which affect prediction value this month
            - t_split = time interval to split data into train/test sets (integer)
        
        NOTE: Dataframe (df) should include 'Date' parameter as a column; the index should be integers, in chronological order
        '''

### raise exceptions if certain inputs not supplied
        if not predvar:
            raise Exception('Please supply prediction variable... Exiting.')
        if not l_exovar:
            raise Exception('Please supply list of exogenous variables... Exiting.')
            
### print variable for prediction
        print(f'Validating model predicting "{predvar}" variable...')
        print('-----------------------------------')
    
### add prediction variable to exogenous (this month) & indicator (next month) variables for predicting @ t+1
        if l_indvar:
            l_exovar = [predvar] + l_exovar + l_indvar
        else:
            l_exovar = [predvar] + l_exovar

### shift prediction & indicator variables... RIGHT NOW ONLY SHIFTS BY ONE MONTH
        self.validate_data[f'Shift_{predvar}'] = self.validate_data[predvar].shift(periods=-1)
        if l_indvar:
            self.validate_data[l_indvar] = self.validate_data[l_indvar].shift(periods=-1) 
        self.validate_data = self.validate_data.iloc[:-1] # after pulling indicator variables, remove last entry

### parameters for generating splits
        idx_start = self.validate_data[self.validate_data.index == self.validate_data.index.max()-pd.DateOffset(months=t_split-1)].index[0] # MONTHS
        idx_end = self.validate_data.index.max() #+ pd.DateOffset(months=1)
        idx_dates = pd.date_range(idx_start, idx_end, freq='MS') # MONTHS
        
### create frame for storing projections
        cols_proj = ['Validation']
        df_proj = pd.DataFrame(index=idx_dates, columns=cols_proj)
        df_feat_importance = pd.DataFrame(index=idx_dates, columns=l_exovar, dtype=float)

### walk-forward validation
        for nidx,idx in enumerate(idx_dates):
            df_train = self.validate_data[:idx-pd.DateOffset(months=1)] # train using entries 0 --> t-1
            df_test = self.validate_data[idx-pd.DateOffset(months=1):idx].iloc[1:] # forecast next entry (t)... MONTHS... SO JANKY
#             print(df_train, df_test) # if you want to get a feel for how this works...
    
### train RF model
            model = skle.RandomForestRegressor(n_estimators=1000, random_state=20210606).fit(X=df_train[l_exovar], y=df_train[f'Shift_{predvar}'])
            df_feat_importance.loc[idx] = model.feature_importances_ # keep track of feature importance over iterations

### get a feel for how model fits training data... poor indicator but just to get a feel
            r2 = model.score(df_train[l_exovar], df_train[f'Shift_{predvar}']) 
            print(f'R-squared = {r2:0.2f} ({idx})') 

### test on hold-out set (single value @ t+1)
            forecast = model.predict(X=df_test[l_exovar])

### add projections & related metrics for next step    
            df_proj.loc[idx, 'Validation'] = forecast[0] # forecast

### assign results to self
        self.validation = pd.DataFrame(df_proj['Validation'].astype(float))
        self.validate_data = self.validate_data.join(df_proj)
        self.feature_importance = df_feat_importance
        self.model = model

### shift variables back
        if l_indvar:
            self.validate_data[l_indvar] = self.validate_data[l_indvar].shift(periods=1) # shift indicator variables back 

#         return(self.validation, self.feature_importance, self.model)
        return(self.validation)


### make forecast iteratively...
    def forecast(self, predvar=None, l_exovar=None, l_indvar=None, date_latest=None, t_forecast=3):
        '''
        Generates forecasts using validated random forest model. Can be used for external validation. New parameters:
            - date_latest = the last date for which historical data is available (datetime-interpretable string)
        
        NOTE: Requires user to set up dataframe s.t. future data can be filled in (& indicator variables are available). Will only fill out to last available date.
        '''
        
### make null data in predictor variable column, if present
        if date_latest:
            self.date_latest = pd.to_datetime(date_latest) # + pd.DateOffset(months=1)
            self.forecast_data.loc[self.forecast_data.index > self.date_latest, f'{predvar}'] = np.nan # update date for forecasting instead of validation
#             print(self.forecast_data)
        else: 
            self.forecast_data.loc[self.forecast_data.index >= self.date_split, f'{predvar}'] = np.nan 

### if validation already occurred, "Forecast" column will already be present. Rename before progressing....
        if 'Forecast' in self.forecast_data.columns:
            print('\n`Forecast` column already present. Changing column name to `Forecast_OLD`...')
            if 'Forecast_OLD' in self.forecast_data.columns:
                del(self.forecast_data['Forecast_OLD'])
            self.forecast_data = self.forecast_data.rename(columns={'Forecast':'Forecast_OLD'})

### print forecast variable
        print(f'\nForecasting "{predvar}" variable...') 
        print('-----------------------------------')
    
### add prediction variable to exogenous (this month) & indicator (next month) variables for predicting @ t+1
        if l_indvar:
            l_exovar = [predvar] + l_exovar + l_indvar
        else:
            l_exovar = [predvar] + l_exovar
        
### shift prediction & indicator variables... RIGHT NOW ONLY SHIFTS BY ONE MONTH
        self.forecast_data[f'Shift_{predvar}'] = self.forecast_data[predvar].shift(periods=-1)
        if l_indvar:
            self.forecast_data[l_indvar] = self.forecast_data[l_indvar].shift(periods=-1) 

### define indicies for projections    
        l_idx_proj = self.forecast_data[self.forecast_data[f'Shift_{predvar}'].isna()].index.tolist()[:t_forecast]
    
### define new column to store forecasts
        col_forecast = 'Forecast'
        df_forecast = pd.DataFrame(columns=[col_forecast], index=pd.date_range(l_idx_proj[0], l_idx_proj[-1]+pd.DateOffset(months=1), freq='MS'))

### forecast iteratively 
        for idx_proj in l_idx_proj:
    
### forecast next step
            idx_proj_prev = idx_proj - pd.DateOffset(months=1)
            idx_proj_next = idx_proj + pd.DateOffset(months=1)
#             print(self.forecast_data[idx_proj:idx_proj_next].iloc[:1][l_exovar])
            forecast_next = self.model.predict(X=self.forecast_data[idx_proj:idx_proj_next].iloc[:1][l_exovar])[0]
            print(f'Forecast = {forecast_next:0.2f} ({idx_proj_next})') 
    
### add forecast to actual & shifted actual
            self.forecast_data.loc[idx_proj_prev:idx_proj, f'Shift_{predvar}'].iloc[1:] = forecast_next
            self.forecast_data.loc[idx_proj:idx_proj_next, f'{predvar}'].iloc[1:] = forecast_next
            df_forecast.loc[idx_proj:idx_proj_next, col_forecast].iloc[1:] = forecast_next # for easier plotting later...
            
### shift variables back
        if l_indvar:
            self.forecast_data[l_indvar] = self.forecast_data[l_indvar].shift(periods=1) # shift indicator variables back 
            
### drop unnecessary future data & add to self
        self.forecasts = pd.DataFrame(df_forecast.dropna().astype(float))
#         self.forecast_data = self.forecast_data.dropna(subset=[f'{predvar}'])
        self.forecast_data = self.forecast_data.join(df_forecast)

        return(self.forecasts)
 